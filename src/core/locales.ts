import { existsSync } from 'node:fs';
import fs from 'node:fs/promises';
import path from 'node:path';

import { logger } from '@/core/logger';

export const commonPaths = ['locales', 'src/locales', 'public/locales'];

export const isDirectory = async (path: string): Promise<boolean> => {
	try {
		const stat = await fs.stat(path);
		return stat.isDirectory();
	} catch {
		return false;
	}
};

export const findLocalesPath = async (): Promise<string | null> => {
	for (const pathName of commonPaths) {
		const fullPath = path.join(process.cwd(), pathName);

		if (existsSync(fullPath) && (await isDirectory(fullPath))) return fullPath;
	}

	return null;
};

export const loadLocales = async (localesPath: string): Promise<LocaleData> => {
	const files = await fs.readdir(localesPath);

	const data: LocaleData = {};

	for (const file of files) {
		if (file.endsWith('.json')) {
			const lang = path.basename(file);
			const filePath = path.join(localesPath, file);

			try {
				const content = await fs.readFile(filePath, 'utf-8');

				data[lang] = JSON.parse(content);
			} catch (error) {
				logger.error(`error parsing ${filePath}: ${error}`, { icon: '❌' });
			}
		}
	}

	return data;
};

export const saveLocales = async (localesPath: string, data: LocaleData) => {
	for (const [lang, translations] of Object.entries(data)) {
		const filePath = path.join(localesPath, `${lang}.json`);
		const backupPath = path.join(localesPath, `${lang}.json.bak`);
	
		try {
			if (existsSync(filePath)) await fs.copyFile(filePath, backupPath);
			await fs.writeFile(filePath, `${JSON.stringify(translations, null, 2)}\n`);
		} catch (error) {
			logger.error(`Error saving ${filePath}: ${error}`, { icon: '❌' })
		}
	} 
}

export const generateTypes = async (localesPath: string, data: LocaleData): Promise<void> => {
	const baseLang = Object.keys(data)[0];
	if (!baseLang) return;

	if (!data[baseLang]) return;

	const keys = Object.keys(data[baseLang]);
	if (keys.length === 0) return;

	const typeName = 'I18nKey';
	const typeContent = `// This file is auto-generated by kaf-i18n. Do not edit.\n\nexport type ${typeName} = \n  | "${keys.join('"\n  | "')}";\n`;

	const outputPath = path.join(localesPath, 'i18n.d.ts');

	try {
		await fs.writeFile(outputPath, typeContent);
		logger.success(`Type definitions generated at ${outputPath}`, {	icon: '✅' });
	} catch (error) {
		logger.error(`Error generating type definitions: ${error}`, { icon: '❌' });
	}
};
